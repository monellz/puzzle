#include <cstdint>
#include <cstdlib>
#include <string_view>
#include <utility>
#include <variant>
#include <vector>

#include "puzzle/frontend/ast.h"
using u8 = uint8_t;
using u16 = uint16_t;
using u32 = uint32_t;

struct Token {
  enum Kind : u32 {
    _Eps,
    _Eof,
    _Err,
    Or,
    And,
    Eq,
    Ne,
    Lt,
    Le,
    Ge,
    Gt,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Unary,
    RPar,
    Empty,
    Else,
    In,
    Out,
    Grid,
    Const,
    If,
    Stencil,
    Assign,
    Comma,
    Semi,
    Not,
    LPar,
    LBrk,
    RBrk,
    LBrc,
    RBrc,
    IntLit,
    FloatLit,
    Ident
  } kind;
  std::string_view piece;
  u32 line, col;
};

using StackItem = std::variant<Token, Module, std::vector<Decl>, Decl, Kernel, Block *, std::vector<Stmt *>, Stmt *,
                               std::vector<int>, Expr *, std::vector<Expr *>>;

struct Lexer {
  std::string_view string;
  u32 line, col;

  explicit Lexer(std::string_view string) : string(string), line(1), col(1) {}
  Token next();
};

struct Parser {
  std::variant<Module, Token> parse(Lexer &lexer);
};

Token Lexer::next() {
  const static Token::Kind ACC[] = {
      Token::_Err,     Token::_Err,   Token::_Eps,     Token::Not,     Token::Mod,   Token::_Err,  Token::LPar,
      Token::RPar,     Token::Mul,    Token::Add,      Token::Comma,   Token::Sub,   Token::Div,   Token::IntLit,
      Token::IntLit,   Token::Semi,   Token::Lt,       Token::Assign,  Token::Gt,    Token::Ident, Token::LBrk,
      Token::RBrk,     Token::Ident,  Token::Ident,    Token::Ident,   Token::Ident, Token::Ident, Token::Ident,
      Token::LBrc,     Token::_Err,   Token::RBrc,     Token::Ne,      Token::And,   Token::_Err,  Token::_Eps,
      Token::FloatLit, Token::_Err,   Token::Le,       Token::Eq,      Token::Ge,    Token::Ident, Token::Ident,
      Token::Ident,    Token::If,     Token::In,       Token::Ident,   Token::Ident, Token::Or,    Token::_Err,
      Token::_Err,     Token::IntLit, Token::Ident,    Token::Ident,   Token::Ident, Token::Out,   Token::Ident,
      Token::_Eps,     Token::_Err,   Token::FloatLit, Token::Ident,   Token::Else,  Token::Grid,  Token::Ident,
      Token::Const,    Token::Ident,  Token::Ident,    Token::Stencil,
  };
  const static u8 EC[] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  1,  3,  0,  0,  0,  4,  5,  0,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 0,  16, 17, 18, 19, 0,  0,  20, 20, 20, 20, 21, 20, 22, 22, 22, 22, 22, 22, 22,
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 0,  24, 0,  22, 0,  20, 20, 25, 26, 27, 28, 29,
      22, 30, 22, 22, 31, 22, 32, 33, 22, 22, 34, 35, 36, 37, 22, 22, 38, 22, 22, 39, 40, 41, 0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
  const static u8 DFA_EDGE[][42] = {
      {1,  2,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 1,  12, 13, 14, 15, 16, 17, 18, 19,
       19, 19, 20, 21, 22, 19, 23, 19, 24, 25, 19, 19, 26, 19, 27, 19, 19, 19, 28, 29, 30},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 14, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 14, 14, 0, 0,  0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0,  0, 36, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 14, 14, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0,  0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 40, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 41, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 42, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 43, 19, 19, 19, 44, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 45, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 46, 19, 19, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {33, 33, 33, 33, 33, 33, 33, 33, 48, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
       33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33},
      {34, 34, 0,  34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
       34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34},
      {0,  0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 35, 35, 0, 0, 0, 0, 0,
       49, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0,  0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 50, 50, 0, 0, 0, 0, 50,
       50, 0, 0, 0, 50, 50, 50, 50, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 51, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 52, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 53, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 54, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 55, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 56, 33, 33, 33, 33, 33, 33, 33,
       33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 57, 0, 57, 0, 0, 58, 58, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0,  0, 0, 0, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 50, 50, 0, 0, 0, 0, 50,
       50, 0, 0, 0, 50, 50, 50, 50, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 59, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 60, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 61, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 62, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 63, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 64, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 65, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 66, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
      {0,  0,  0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  19, 19, 0,  0,  0, 0, 19,
       19, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0},
  };
  u32 l = line, c = col;
  Token::Kind last_acc = Token::_Err;
  u32 state = 0, i = 0;
  while (true) {
    u32 ch, nxt;
    if (i < string.size()) {
      ch = string[i], nxt = DFA_EDGE[state][EC[ch]];
    } else {
      ch = nxt = 0;
    }
    Token::Kind acc = ACC[nxt];
    if (acc != Token::_Err) {
      last_acc = acc;
    }
    state = nxt;
    if (nxt == 0) {  // dead, should not eat this char
      // we are not using substr here, because it does range check and may throws exception
      std::string_view piece(string.data(), i);
      string = std::string_view(string.data() + i, string.size() - i);
      if (i == 0 || last_acc != Token::_Eps) {
        return Token{i == 0 ? Token::_Eof : last_acc, piece, l, c};
      } else {
        l = line, c = col, last_acc = Token::_Err, state = 0, i = 0;
      }
    } else {  // continue, eat this char
      if (ch == '\n') {
        ++line, col = 1;
      } else {
        ++col;
      }
      ++i;
    }
  }
}

std::variant<Module, Token> Parser::parse(Lexer &lexer) {
  const static u8 PROD[] = {0,  0,  0,  1,  1,  1,  1,  2,  2,  3,  3,  4,  4,  4,  5,  6,  7,  7,
                            8,  8,  8,  9,  9,  10, 10, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12,
                            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 14, 14, 15};
  const static u16 ACTION[][38] = {
      {
          3, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 9, 9, 9, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9,
      },
      {
          3, 2, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 8, 12, 16, 20, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 24,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 36, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 40, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 44, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 33, 3, 3, 3, 3, 3, 3, 3, 3, 48,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1,
      },
      {
          3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 76, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 80, 53, 53, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 84, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 88, 29, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 41, 41, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 92, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 96, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 100, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 104, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 108, 112, 3,
      },
      {
          3, 25, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 25, 25, 25, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 48,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 120, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 33, 3, 3, 3, 3, 3, 3, 3, 3, 48,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 33, 3, 3, 3, 3, 3, 3, 3, 3, 48,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 33, 3, 3, 3, 3, 3, 3, 3, 3, 48,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 49, 49, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 45, 45, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 37, 37, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          3, 3, 3, 3, 3, 69, 3, 3, 3, 3, 3, 3, 3, 3, 69, 69, 3, 3, 69,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 144, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 148, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 152, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 156, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,   3,   3, 3, 3,
          3, 3, 3, 3, 3, 160, 3, 3, 3, 3, 3, 3, 3, 3, 120, 164, 3, 3, 168,
      },
      {
          3, 57, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 57, 57, 57, 57, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 57,
      },
      {
          3, 13, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 13, 13, 13, 13, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 13,
      },
      {
          3, 17, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 17, 17, 17, 17, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17,
      },
      {
          3, 21, 3,  3,  3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 21, 21, 21, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 21,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 180, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3,  3, 3, 3, 3, 3,  3, 3, 3, 3,  3, 3, 3, 3, 3,  3,  3, 3, 3,
          61, 3, 3, 3, 3, 61, 3, 3, 3, 61, 3, 3, 3, 3, 61, 61, 3, 3, 61,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 184, 3, 3, 3, 3, 3, 3,
      },
      {
          3,  3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          81, 3, 3, 3, 3, 81, 3, 3, 3, 3, 3, 3, 3, 3, 81, 81, 3, 3, 81,
      },
      {
          3, 3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          3, 3, 3, 3, 3, 65, 3, 3, 3, 3, 3, 3, 3, 3, 65, 65, 3, 3, 65,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3,   3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 97, 3, 3, 220, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 3, 189, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   189, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 185, 3, 185, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   185, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 3, 181, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   181, 3,   3,   248, 3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 304, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3,   3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 105, 3, 3, 3, 3, 105, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 308, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3,  3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 312, 3, 3, 3, 3, 93, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 3, 161, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   161, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 3, 165, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   165, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 3, 169, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   169, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 316, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  3, 3, 3,   3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 97, 3, 3, 220, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3,
          3, 3, 3, 3, 3, 160, 3, 3, 3, 3, 3, 3, 3, 3, 120, 3, 3, 3, 168,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 380, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 384, 3, 3,
      },
      {
          3, 3, 3, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 3, 173, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   173, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 388, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 157, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 157, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   157, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 153, 153, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 153, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   153, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 145, 145, 145, 145, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 145, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   145, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 149, 149, 149, 149, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 149, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   149, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 129, 129, 129, 129, 129, 129, 129, 129, 284, 288, 292, 296, 300, 3, 129, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   129, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 133, 133, 133, 133, 133, 133, 133, 133, 284, 288, 292, 296, 300, 3, 133, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   133, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 137, 137, 137, 137, 137, 137, 137, 137, 284, 288, 292, 296, 300, 3, 137, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   137, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 141, 141, 141, 141, 141, 141, 141, 141, 284, 288, 292, 296, 300, 3, 141, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   141, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 292, 296, 300, 3, 109, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   109, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 292, 296, 300, 3, 113, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   113, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 3, 117, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   117, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 3, 121, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   121, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 3, 125, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   125, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3,   3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          392, 3, 3, 3, 3, 89, 3, 3, 3, 3, 3, 3, 3, 3, 89, 89, 3, 3, 89,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,   188, 192, 3, 3, 3, 3,   3,   3,
          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 196, 200, 3,   3, 3, 3, 204, 208, 212,
      },
      {
          3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3,   3, 3, 3, 3, 3,
          3, 3, 3, 3, 3, 3, 3, 3, 101, 3, 3, 3, 3, 101, 3, 3, 3, 3, 3,
      },
      {
          3, 3, 3, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 3, 177, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   177, 3,   3,   3,   3,   3,   3,   3, 3,   3,
      },
      {
          3, 3, 3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3, 3,   3, 3, 3, 3,
          3, 3, 3, 3, 3, 160, 3, 3, 3, 3, 3, 3, 3, 3, 120, 3, 3, 3, 168,
      },
      {
          3,  3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          77, 3, 3, 3, 3, 77, 3, 3, 3, 3, 3, 3, 3, 3, 77, 77, 3, 3, 77,
      },
      {
          3, 3, 3, 252, 256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 3, 3, 3,
          3, 3, 3, 3,   3,   3,   3,   3,   3,   408, 3,   3,   3,   3,   3,   3,   3, 3, 3,
      },
      {
          3,  3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          85, 3, 3, 3, 3, 85, 3, 3, 3, 3, 3, 3, 3, 3, 85, 85, 3, 3, 85,
      },
      {
          3,  3, 3, 3, 3, 3,  3, 3, 3, 3, 3, 3, 3, 3, 3,  3,  3, 3, 3,
          73, 3, 3, 3, 3, 73, 3, 3, 3, 3, 3, 3, 3, 3, 73, 73, 3, 3, 73,
      },
  };
  const static u8 GOTO[][16] = {
      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 7, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 32, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 33, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 34, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 43, 0, 44, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 0, 0, 0, 0},  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 57, 0, 0, 0, 0},  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 93, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 43, 0, 94, 0, 0, 0, 0, 0, 0, 0},  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0},   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 43, 0, 101, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  };
  std::vector<std::pair<StackItem, u8>> stk;
  stk.emplace_back(StackItem{}, 0);
  u32 state = 0;
  Token token = lexer.next();
  while (true) {
    u32 act = ACTION[state][token.kind], act_val = act >> 2;
    switch (act & 3) {
      case 0: {
        stk.emplace_back(token, act_val);
        state = act_val;
        token = lexer.next();
        break;
      }
      case 1: {
        StackItem __;
        // we are confident that the value must be what we expect, so directly dereference the return value of
        // `std::get_if` we are not using `std::get`, because it performs runtime check, and throws exceptions when
        // fails
        switch (act_val) {
          case 0: {
            [[maybe_unused]] std::vector<Decl> _2(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Module _1(std::move(*std::get_if<Module>(&stk.back().first)));
            stk.pop_back();
            for (Decl &d : _2) {
              _1.decls.emplace_back(std::move(d));
            }
            __ = std::move(_1);
            break;
          }
          case 1: {
            [[maybe_unused]] Kernel _2(std::move(*std::get_if<Kernel>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Module _1(std::move(*std::get_if<Module>(&stk.back().first)));
            stk.pop_back();
            _1.kernels.emplace_back(std::move(_2));
            __ = std::move(_1);
            break;
          }
          case 2: {
            __ = Module();
            break;
          }
          case 3: {
            [[maybe_unused]] Token _6(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Decl> _5(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            int _dim = (int)strtol(_3.piece.data(), nullptr, 10);
            for (Decl &d : _5) {
              d.kind = Decl::kIn;
              d.dim = _dim;
            }
            __ = std::move(_5);
            break;
          }
          case 4: {
            [[maybe_unused]] Token _6(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Decl> _5(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            int _dim = (int)strtol(_3.piece.data(), nullptr, 10);
            for (Decl &d : _5) {
              d.kind = Decl::kOut;
              d.dim = _dim;
            }
            __ = std::move(_5);
            break;
          }
          case 5: {
            [[maybe_unused]] Token _6(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Decl> _5(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            int _dim = (int)strtol(_3.piece.data(), nullptr, 10);
            for (Decl &d : _5) {
              d.kind = Decl::kGrid;
              d.dim = _dim;
            }
            __ = std::move(_5);
            break;
          }
          case 6: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Decl> _2(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            for (Decl &d : _2) {
              d.kind = Decl::kConst;
            }
            __ = std::move(_2);
            break;
          }
          case 7: {
            [[maybe_unused]] std::vector<Decl> _1(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            __ = std::move(_1);
            break;
          }
          case 8: {
            __ = std::vector<Decl>();
            break;
          }
          case 9: {
            [[maybe_unused]] Decl _3(std::move(*std::get_if<Decl>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Decl> _1(std::move(*std::get_if<std::vector<Decl>>(&stk.back().first)));
            stk.pop_back();
            _1.push_back(std::move(_3));
            __ = std::move(_1);
            break;
          }
          case 10: {
            [[maybe_unused]] Decl _1(std::move(*std::get_if<Decl>(&stk.back().first)));
            stk.pop_back();
            __ = std::vector({std::move(_1)});
            break;
          }
          case 11: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            double _f = strtod(_3.piece.data(), nullptr);
            __ = Decl{_1.piece, Decl::kConst, 0, _f};
            break;
          }
          case 12: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            double _f = strtod(_3.piece.data(), nullptr);
            __ = Decl{_1.piece, Decl::kConst, 0, _f};
            break;
          }
          case 13: {
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = Decl{_1.piece, Decl::kUnknown, 0, 0.0};
            break;
          }
          case 14: {
            [[maybe_unused]] Token _5(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Block *_4(std::move(*std::get_if<Block *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = Kernel{_1.piece, std::move(_4)};
            break;
          }
          case 15: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Stmt *> _2(std::move(*std::get_if<std::vector<Stmt *>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Block{Stmt::kBlock, std::move(_2)};
            break;
          }
          case 16: {
            [[maybe_unused]] Stmt *_2(std::move(*std::get_if<Stmt *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Stmt *> _1(std::move(*std::get_if<std::vector<Stmt *>>(&stk.back().first)));
            stk.pop_back();
            _1.push_back(_2);
            __ = std::move(_1);
            break;
          }
          case 17: {
            __ = std::vector<Stmt *>();
            break;
          }
          case 18: {
            [[maybe_unused]] Token _7(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_6(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _5(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<int> _3(std::move(*std::get_if<std::vector<int>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Assign{Stmt::kAssign, _1.piece, std::move(_3), _6};
            break;
          }
          case 19: {
            [[maybe_unused]] Stmt *_6(std::move(*std::get_if<Stmt *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Stmt *_5(std::move(*std::get_if<Stmt *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new If{Stmt::kIf, _3, _5, _6};
            break;
          }
          case 20: {
            [[maybe_unused]] Block *_1(std::move(*std::get_if<Block *>(&stk.back().first)));
            stk.pop_back();
            __ = _1;
            break;
          }
          case 21: {
            [[maybe_unused]] Stmt *_2(std::move(*std::get_if<Stmt *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = _2;
            break;
          }
          case 22: {
            __ = static_cast<Stmt *>(nullptr);
            break;
          }
          case 23: {
            [[maybe_unused]] std::vector<int> _1(std::move(*std::get_if<std::vector<int>>(&stk.back().first)));
            stk.pop_back();
            __ = std::move(_1);
            break;
          }
          case 24: {
            __ = std::vector<int>();
            break;
          }
          case 25: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<int> _1(std::move(*std::get_if<std::vector<int>>(&stk.back().first)));
            stk.pop_back();
            _1.push_back((int)strtol(_3.piece.data(), nullptr, 10));
            __ = std::move(_1);
            break;
          }
          case 26: {
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = std::vector<int>({(int)strtol(_1.piece.data(), nullptr, 10)});
            break;
          }
          case 27: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kAdd, _1, _3};
            break;
          }
          case 28: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kSub, _1, _3};
            break;
          }
          case 29: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kMul, _1, _3};
            break;
          }
          case 30: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kDiv, _1, _3};
            break;
          }
          case 31: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kMod, _1, _3};
            break;
          }
          case 32: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kLt, _1, _3};
            break;
          }
          case 33: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kLe, _1, _3};
            break;
          }
          case 34: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kGe, _1, _3};
            break;
          }
          case 35: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kGt, _1, _3};
            break;
          }
          case 36: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kEq, _1, _3};
            break;
          }
          case 37: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kNe, _1, _3};
            break;
          }
          case 38: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kAnd, _1, _3};
            break;
          }
          case 39: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kOr, _1, _3};
            break;
          }
          case 40: {
            [[maybe_unused]] Expr *_2(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = _2;
            break;
          }
          case 41: {
            [[maybe_unused]] Expr *_2(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kSub, &FloatLit::ZERO, _2};
            break;
          }
          case 42: {
            [[maybe_unused]] Expr *_2(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Binary{Expr::kEq, &FloatLit::ZERO, _2};
            break;
          }
          case 43: {
            [[maybe_unused]] Token _3(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Expr *_2(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = _2;
            break;
          }
          case 44: {
            [[maybe_unused]] Token _4(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<int> _3(std::move(*std::get_if<std::vector<int>>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Access{Expr::kAccess, _1.piece, std::move(_3)};
            break;
          }
          case 45: {
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            __ = new Const{Expr::kConst, _1.piece};
            break;
          }
          case 46: {
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            double _f = strtod(_1.piece.data(), nullptr);
            __ = new FloatLit{Expr::kFloatLit, _f};
            break;
          }
          case 47: {
            [[maybe_unused]] Token _1(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            double _f = strtod(_1.piece.data(), nullptr);
            __ = new FloatLit{Expr::kFloatLit, _f};
            break;
          }
          case 48: {
            [[maybe_unused]] std::vector<Expr *> _1(std::move(*std::get_if<std::vector<Expr *>>(&stk.back().first)));
            stk.pop_back();
            __ = std::move(_1);
            break;
          }
          case 49: {
            __ = std::vector<Expr *>();
            break;
          }
          case 50: {
            [[maybe_unused]] Expr *_3(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] Token _2(std::move(*std::get_if<Token>(&stk.back().first)));
            stk.pop_back();
            [[maybe_unused]] std::vector<Expr *> _1(std::move(*std::get_if<std::vector<Expr *>>(&stk.back().first)));
            stk.pop_back();
            _1.push_back(_3);
            __ = std::move(_1);
            break;
          }
          case 51: {
            [[maybe_unused]] Expr *_1(std::move(*std::get_if<Expr *>(&stk.back().first)));
            stk.pop_back();
            __ = std::vector<Expr *>({_1});
            break;
          }
          case 52: {
            [[maybe_unused]] Module _1(std::move(*std::get_if<Module>(&stk.back().first)));
            stk.pop_back();
            __ = _1;
            break;
          }

          default:
            __builtin_unreachable();
        }
        u8 nxt = GOTO[stk.back().second][PROD[act_val]];
        stk.emplace_back(std::move(__), nxt);
        state = nxt;
        break;
      }
      case 2:
        return std::move(*std::get_if<Module>(&stk.back().first));
      case 3:
        return token;
      default:
        __builtin_unreachable();
    }
  }
}
