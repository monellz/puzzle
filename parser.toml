include = '''#include "puzzle/frontend/ast.h"
namespace puzzle::ast {'''
epilogue = '''}'''

priority = [
  { assoc = 'left', terms = ['Or'] },
  { assoc = 'left', terms = ['And'] },
  { assoc = 'left', terms = ['Eq', 'Ne'] },
  { assoc = 'left', terms = ['Lt', 'Le', 'Ge', 'Gt'] },
  { assoc = 'left', terms = ['Add', 'Sub'] },
  { assoc = 'left', terms = ['Mul', 'Div', 'Mod'] },
  { assoc = 'no_assoc', terms = ['Unary'] },
  { assoc = 'no_assoc', terms = ['RPar'] },
  { assoc = 'left', terms = ['Empty'] },
  { assoc = 'left', terms = ['Else'] },
]

start = 'Module'

[lexical]
'In' = 'In'
'Out' = 'Out'
'Grid' = 'Grid'
'Const' = 'Const'
'Pad' = 'Pad'
'UpperBound' = 'UpperBound'
'LowerBound' = 'LowerBound'
'if' = 'If'
'else' = 'Else'
'stencil' = 'Stencil'
'\+' = 'Add'
'-' = 'Sub'
'\*' = 'Mul'
'/' = 'Div'
'%' = 'Mod'
'<' = 'Lt'
'<=' = 'Le'
'>' = 'Gt'
'>=' = 'Ge'
'==' = 'Eq'
'!=' = 'Ne'
'&&' = 'And'
'\|\|' = 'Or'
'=' = 'Assign'
',' = 'Comma'
';' = 'Semi' # short for semicolon
'!' = 'Not'
'\(' = 'LPar' # short for parenthesis
'\)' = 'RPar'
'\[' = 'LBrk' # short for bracket
'\]' = 'RBrk'
'\{' = 'LBrc' # short for brace
'\}' = 'RBrc'
'//[^\n]*' = '_Eps' # line comment
'/\*[^*]*(\*[^/][^*]*)*\*/' = '_Eps' # block comment
'\s+' = '_Eps'
'[-+]?\d+|(0x[0-9a-fA-F]+)' = 'IntLit'
'[-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?' = 'FloatLit'
'[_A-Za-z]\w*' = 'Ident'
'.' = '_Err'

[[production]]
lhs = 'Module'
ty = 'std::unique_ptr<Module>'
rhs = [
  { rhs = ['Module', 'VarDecl'], act = 'for (auto &d : _2) { _1->decls.push_back(std::move(d)); } _1->update_loc(lexer); __ = std::move(_1);' },
  { rhs = ['Module', 'InfoDecl'], act = 'for (auto &i : _2) { _1->infos.push_back(std::move(i)); } _1->update_loc(lexer); __ = std::move(_1);' },
  { rhs = ['Module', 'KernelDecl'], act = '_1->kernels.push_back(std::move(_2)); _1->update_loc(lexer); __ = std::move(_1);' },
  { rhs = [], act = 'auto __m = std::make_unique<Module>(); __m->update_loc(lexer); __ = std::move(__m);' },
]

[[production]]
lhs = 'VarDecl'
ty = 'std::vector<std::unique_ptr<Decl>>'
rhs = [
  { rhs = ['In', 'Lt', 'IntLit', 'Gt', 'DeclList', 'Semi'], act = 'int _r = to_dec(_3.piece); for (auto &d : _5) { d->kind = Decl::kIn; d->rank = _r;} __ = std::move(_5);'},
  { rhs = ['Out', 'Lt', 'IntLit', 'Gt', 'DeclList', 'Semi'], act = 'int _r = to_dec(_3.piece); for (auto &d : _5) { d->kind = Decl::kOut; d->rank = _r;} __ = std::move(_5);'},
  { rhs = ['Grid', 'Lt', 'IntLit', 'Gt', 'DeclList', 'Semi'], act = 'int _r = to_dec(_3.piece); for (auto &d : _5) { d->kind = Decl::kGrid; d->rank = _r;} __ = std::move(_5);'},
  { rhs = ['Const', 'DeclList', 'Semi'], act = 'for (auto &d : _2) { d->kind = Decl::kConst;} __ = std::move(_2);'},
]

[[production]]
lhs = 'InfoDecl'
ty = 'std::vector<std::unique_ptr<Info>>'
rhs = [
  { rhs = ['UpperBound', 'InfoList', 'Semi'], act = 'for (auto &i : _2) { i->kind = Info::kUpperBound;} __ = std::move(_2);'},
  { rhs = ['LowerBound', 'InfoList', 'Semi'], act = 'for (auto &i : _2) { i->kind = Info::kLowerBound;} __ = std::move(_2);'},
  { rhs = ['Pad', 'InfoList', 'Semi'], act = 'for (auto &i : _2) { i->kind = Info::kPad;} __ = std::move(_2);'},
]

[[production]]
lhs = 'InfoList'
ty = 'std::vector<std::unique_ptr<Info>>'
rhs = [
  { rhs = ['InfoList1'], act = '__ = std::move(_1);' },
  { rhs = [], act = '__ = std::move(std::vector<std::unique_ptr<Info>>());' },
]

[[production]]
lhs = 'InfoList1'
ty = 'std::vector<std::unique_ptr<Info>>'
rhs = [
  { rhs = ['InfoList1', 'Comma', 'Ident', 'LPar', 'Index', 'RPar'], act = '_1.emplace_back(std::make_unique<Info>(Info::kUnknown, _3.piece, std::move(_5))); _1.back()->update_loc(lexer); __ = std::move(_1);'},
  { rhs = ['Ident', 'LPar', 'Index', 'RPar'], act = 'auto __v = std::vector<std::unique_ptr<Info>>(); __v.emplace_back(std::make_unique<Info>(Info::kUnknown, _1.piece, std::move(_3))); __v[0]->update_loc(lexer); __ = std::move(__v);'},
]


[[production]]
lhs = 'DeclList'
ty = 'std::vector<std::unique_ptr<Decl>>'
rhs = [
  { rhs = ['DeclList1'], act = '__ = std::move(_1);' },
  { rhs = [], act = '__ = std::move(std::vector<std::unique_ptr<Decl>>());' },
]

[[production]]
lhs = 'DeclList1'
ty = 'std::vector<std::unique_ptr<Decl>>'
rhs = [
  { rhs = ['DeclList1', 'Comma', 'Decl'], act = '_1.push_back(std::move(_3)); __ = std::move(_1);'},
  { rhs = ['Decl'], act = 'auto __v = std::vector<std::unique_ptr<Decl>>(); __v.push_back(std::move(_1)); __ = std::move(__v);'},
]

[[production]]
lhs = 'Decl'
ty = 'std::unique_ptr<Decl>'
rhs = [
  { rhs = ['Ident', 'Assign', 'FloatLit'], act = 'double _f = to_double(_3.piece); auto __d = std::make_unique<Decl>(Decl::kConst, _1.piece, 0, _f); __d->update_loc(lexer); __ = std::move(__d);'},
  { rhs = ['Ident', 'Assign', 'IntLit'], act = 'double _f = to_double(_3.piece); auto __d = std::make_unique<Decl>(Decl::kConst, _1.piece, 0, _f); __d->update_loc(lexer); __ = std::move(__d);'},
  { rhs = ['Ident'], act = 'auto __d = std::make_unique<Decl>(Decl::kUnknown, _1.piece, 0, 0.0); __d->update_loc(lexer); __ = std::move(__d);'},
]

[[production]]
lhs = 'KernelDecl'
ty = 'std::unique_ptr<Kernel>'
rhs = [
  { rhs = ['Ident', 'Assign', 'Stencil', 'Block', 'Semi'], act = 'auto __k = std::make_unique<Kernel>(_1.piece, std::move(_4)); __k->update_loc(lexer); __ = std::move(__k);'},
]

[[production]]
lhs = 'Block'
ty = 'std::unique_ptr<Block>'
rhs = [
  { rhs = ['LBrc', 'StmtList' ,'RBrc'], act = 'auto __b = std::make_unique<Block>(std::move(_2)); __b->update_loc(lexer); __ = std::move(__b);' },
]

[[production]]
lhs = 'StmtList'
ty = 'std::vector<std::unique_ptr<Stmt>>'
rhs = [
  { rhs = ['StmtList', 'Stmt'], act = '_1.push_back(std::move(_2)); __ = std::move(_1);' },
  { rhs = [], act = '__ = std::move(std::vector<std::unique_ptr<Stmt>>());'},
]

[[production]]
lhs = 'Stmt'
ty = 'std::unique_ptr<Stmt>'
rhs = [
  { rhs = ['Ident', 'LBrk', 'Index', 'RBrk', 'Assign', 'Expr', 'Semi'], act = 'auto __s = std::make_unique<Assign>(_1.piece, std::move(_3), std::move(_6)); __s->update_loc(lexer); __ = std::move(__s);'},
  { rhs = ['If', 'LPar', 'Expr', 'RPar', 'Stmt', 'Else0'], act = 'auto __s = std::make_unique<If>(std::move(_3), std::move(_5), std::move(_6)); __s->update_loc(lexer); __ = std::move(__s);'},
  { rhs = ['Block'], act = '_1->update_loc(lexer); __ = std::move(_1);'},
]

[[production]]
lhs = 'Else0'
ty = 'std::unique_ptr<Stmt>'
rhs = [
  { rhs = ['Else', 'Stmt'], act = '_2->update_loc(lexer); __ = std::move(_2);'},
  { rhs = [], act = '__ = std::unique_ptr<Stmt>();', prec = 'Empty'},
]


[[production]]
lhs = 'Index'
ty = 'std::vector<int>'
rhs = [
  { rhs = ['Index1'], act = '__ = std::move(_1);'},
  { rhs = [], act = '__ = std::vector<int>();'},
]

[[production]]
lhs = 'Index1'
ty = 'std::vector<int>'
rhs = [
  { rhs = ['Index1', 'Comma', 'IntLit'], act = '_1.push_back(to_dec(_3.piece)); __ = std::move(_1);'},
  { rhs = ['IntLit'], act = '__ = std::vector<int>({to_dec(_1.piece)});'},
]


# TODO
[[production]]
lhs = 'Expr' # 虽然这个阶段已经可以计算出一些结果了，但是没有必要，统一在typeck阶段再计算
ty = 'std::unique_ptr<Expr>'
rhs = [
  { rhs = ['Expr', 'Add', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kAdd, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Sub', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kSub, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Mul', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kMul, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Div', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kDiv, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Mod', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kMod, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Lt', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kLt, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Le', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kLe, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Ge', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kGe, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Gt', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kGt, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Eq', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kEq, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Ne', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kNe, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'And', 'Expr'], act ='auto __e = std::make_unique<Binary>(Expr::kAnd,std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Expr', 'Or', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kOr, std::move(_1), std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Add', 'Expr'], act = 'auto __e = std::move(_2); __e->update_loc(lexer); __ = std::move(__e);', prec = 'Unary' },
  { rhs = ['Sub', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kSub, FloatLit::ZERO(), std::move(_2)); __e->update_loc(lexer); __ = std::move(__e);', prec = 'Unary' },
  { rhs = ['Not', 'Expr'], act = 'auto __e = std::make_unique<Binary>(Expr::kEq, FloatLit::ZERO(), std::move(_2)); __e->update_loc(lexer); __ = std::move(__e);', prec = 'Unary' },
  { rhs = ['LPar', 'Expr', 'RPar'], act = '_2->update_loc(lexer); __ = std::move(_2);' },
  { rhs = ['Ident', 'LBrk', 'Index', 'RBrk'], act = 'auto __e = std::make_unique<Access>(_1.piece, std::move(_3)); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['Ident'], act = 'auto __e = std::make_unique<Const>(_1.piece); __e->update_loc(lexer); __ = std::move(__e);' },
  { rhs = ['FloatLit'], act = 'double _f = to_double(_1.piece); auto __e = std::make_unique<FloatLit>(_f); __e->update_loc(lexer); __ = std::move(__e);'},
  { rhs = ['IntLit'], act = 'double _f = to_double(_1.piece); auto __e = std::make_unique<FloatLit>(_f); __e->update_loc(lexer); __ = std::move(__e);'},
]

[[production]]
lhs = 'ExprList'
ty = 'std::vector<std::unique_ptr<Expr>>'
rhs = [
  { rhs = ['ExprList1'], act = '__ = std::move(_1);' },
  { rhs = [], act = '__ = std::vector<std::unique_ptr<Expr>>();' },
]

[[production]]
lhs = 'ExprList1'
ty = 'std::vector<std::unique_ptr<Expr>>'
rhs = [
  { rhs = ['ExprList1', 'Comma', 'Expr'], act = '_1.push_back(std::move(_3)); __ = std::move(_1);' },
  { rhs = ['Expr'], act = 'auto __v = std::vector<std::unique_ptr<Expr>>(); __v.push_back(std::move(_1)); __ = std::move(__v);' },
]
